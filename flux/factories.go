// Package flux is a convenience shorthand for creating instances of
// cesium.Flux. It provides all the factories in a nice package name so their
// usage is more straightforward in your code.
package flux

import (
	"github.com/DusanKasan/cesium"
	"github.com/DusanKasan/cesium/internal"
)

type overflowStrategy internal.OverflowStrategy

// OverflowStrategyBuffer when passed to flux.Create instructs the operator to
// buffer the emissions the Subscriber can't process.
const OverflowStrategyBuffer = overflowStrategy(internal.OverflowStrategyBuffer)

// OverflowStrategyDrop when passed to flux.Create instructs the operator to
// discard the emissions the Subscriber can't process.
const OverflowStrategyDrop = overflowStrategy(internal.OverflowStrategyDrop)

// OverflowStrategyError when passed to flux.Create instructs the operator to
// emit the cesium.DownstreamUnableToKeepUpError error if the Subscriber
// can't process the items as fast as they are emitted.
const OverflowStrategyError = overflowStrategy(internal.OverflowStrategyError)

// OverflowStrategyDrop when passed to flux.Create instructs the operator to
// ignore backpressure and emit items as fast as possible, effectivelly turning
// it into an observable.
const OverflowStrategyIgnore = overflowStrategy(internal.OverflowStrategyIgnore)

// Just creates new cesium.Flux that emits the supplied items and completes.
func Just(items ...cesium.T) cesium.Flux {
	return internal.FluxJust(items...)
}

// FromSlice creates new cesium.Flux that emits items from the supplied slice.
func FromSlice(slice []cesium.T) cesium.Flux {
	return internal.FluxFromSlice(slice)
}

// Range creates new cesium.Flux that emits 64bit integers from start to
// (start + count).
func Range(start int, count int) cesium.Flux {
	return internal.FluxRange(start, count)
}

// Empty creates new cesium.Flux that emits no items and completes normally.
func Empty() cesium.Flux {
	return internal.FluxEmpty()
}

// Never creates new cesium.Flux that emits no items and never completes.
func Never() cesium.Flux {
	return internal.FluxNever()
}

// Using uses a resource, generated by a supplier for each individual Subscriber,
// while streaming the value from a Publisher derived from the same resource
// and makes sure the resource is released if the sequence terminates or the
// Subscriber cancels.
func Using(resourceSupplier func() cesium.T, sourceSupplier func(cesium.T) cesium.Publisher, resourceCleanup func(cesium.T)) cesium.Flux {
	return internal.FluxUsing(resourceSupplier, sourceSupplier, resourceCleanup)
}

// Create allows you to programmatically create a cesium.Flux with the
// capability of emitting multiple elements in a synchronous or asynchronous
// manner through the flux.Sink API
func Create(f func(cesium.FluxSink), os overflowStrategy) cesium.Flux {
	return internal.FluxCreate(f, internal.OverflowStrategy(os))
}

// Generate creates a cesium.Flux programmatically by generating signals
// one-by-one when they are requested.
func Generate(f func(cesium.SynchronousSink)) cesium.Flux {
	return internal.FluxGenerate(f)
}

// Defer creates new cesium.Flux by subscribing to the Publisher returned from
// the supplied factory function for each subscribtion.
func Defer(f func() cesium.Publisher) cesium.Flux {
	return internal.FluxDefer(f)
}

// Error creates new cesium.Flux that emits no items and completes with error.
func Error(err error) cesium.Flux {
	return internal.FluxError(err)
}

// FromChannel creates a Flux from a channel that emits items from the channel
// and completes when the channel closes.
func FromChannel(c <-chan cesium.T) cesium.Flux {
	return internal.FluxFromChannel(c)
}
