package internal

import (
	"sync"

	"github.com/DusanKasan/cesium"
)

// Just creates new cesium.Mono that emits the supplied item and completes.
func MonoJust(t cesium.T) cesium.Mono {
	return monoFromCallable(func() (cesium.T, bool) {
		return t, true
	})
}

// JustOrEmpty creates new cesium.Mono that emits the supplied item if it's non-nil
// and completes, otherwise just completes.
func MonoJustOrEmpty(t cesium.T) cesium.Mono {
	return monoFromCallable(func() (cesium.T, bool) {
		return t, t != nil
	})
}

func monoFromCallable(f func() (cesium.T, bool)) cesium.Mono {
	t, ok := f()

	onPublish := func(subscriber cesium.Subscriber, scheduler cesium.Scheduler) cesium.Subscription {
		if scheduler == nil {
			scheduler = SeparateGoroutineScheduler()
		}

		mux := sync.Mutex{}
		cancelled := false
		planned := false
		var cancellable cesium.Cancellable

		sub := &Subscription{
			CancelFunc: func() {
				mux.Lock()
				cancelled = true
				if cancellable != nil {
					cancellable.Cancel()
				}
				mux.Unlock()
			},
			RequestFunc: func(n int64) {
				mux.Lock()
				if cancelled || planned {
					mux.Unlock()
					return
				}

				cancellable = scheduler.Schedule(func(canceller cesium.Canceller) {
					if ok {
						subscriber.OnNext(t)
					}
					subscriber.OnComplete()
				})
				planned = true
				mux.Unlock()
			},
		}

		subscriber.OnSubscribe(sub)
		return sub
	}

	return &ScalarMono{
		&Mono{OnSubscribe: onPublish},
		f,
	}
}

// FromCallable creates new cesium.Mono that emits the item returned from the supplied function. If the function
// returns nil, the returned Mono completes empty.
func MonoFromCallable(f func() cesium.T) cesium.Mono {
	return monoFromCallable(func() (cesium.T, bool) {
		return f(), true
	})
}

// Empty creates new cesium.Mono that emits no items and completes normally.
func MonoEmpty() cesium.Mono {
	return monoFromCallable(func() (cesium.T, bool) {
		return nil, false
	})
}

// Empty creates new cesium.Mono that emits no items and completes with error.
func MonoError(err error) cesium.Mono {
	onPublish := func(subscriber cesium.Subscriber, scheduler cesium.Scheduler) cesium.Subscription {
		if scheduler == nil {
			scheduler = SeparateGoroutineScheduler()
		}

		cancellable := scheduler.Schedule(func(canceller cesium.Canceller) {
			for {
				if canceller.IsCancelled() {
					return
				}

				subscriber.OnError(err)
				return
			}
		})

		sub := &Subscription{
			CancelFunc: func() {
				cancellable.Cancel()
			},
			RequestFunc: func(n int64) {
			},
		}

		subscriber.OnSubscribe(sub)
		return sub
	}

	return &Mono{OnSubscribe: onPublish}
}

// Never creates new cesium.Mono that emits no items and never completes.
func MonoNever() cesium.Mono {
	onPublish := func(subscriber cesium.Subscriber, scheduler cesium.Scheduler) cesium.Subscription {
		if scheduler == nil {
			scheduler = SeparateGoroutineScheduler()
		}

		sub := &Subscription{
			CancelFunc: func() {
			},
			RequestFunc: func(n int64) {
			},
		}

		subscriber.OnSubscribe(sub)
		return sub
	}

	return &Mono{OnSubscribe: onPublish}
}

// Defer creates new cesium.Mono by subscribing to the Mono returned from the supplied
// factory function for each subscribtion.
func MonoDefer(f func() cesium.Mono) cesium.Mono {
	onPublish := func(subscriber cesium.Subscriber, scheduler cesium.Scheduler) cesium.Subscription {
		if scheduler == nil {
			scheduler = SeparateGoroutineScheduler()
		}

		var subscription cesium.Subscription
		subscriptionMux := sync.Mutex{}

		canc := scheduler.Schedule(func(c cesium.Canceller) {
			subscriptionMux.Lock()
			subscription = f().Subscribe(subscriber)
			subscriptionMux.Unlock()
		})

		for {
			subscriptionMux.Lock()
			if subscription != nil {
				subscriptionMux.Unlock()
				break
			}
			subscriptionMux.Unlock()
		}

		sub := &Subscription{
			CancelFunc: func() {
				subscription.Cancel()
				canc.Cancel()
			},
			RequestFunc: func(n int64) {
				subscription.Request(n)
			},
		}

		subscriber.OnSubscribe(sub)
		return sub
	}

	return &Mono{OnSubscribe: onPublish}
}

// Using Uses a resource, generated by a supplier for each individual Subscriber,
// while streaming the value from a Mono derived from the same resource and makes
// sure the resource is released if the sequence terminates or the Subscriber cancels.
func MonoUsing(resourceSupplier func() cesium.T, sourceSupplier func(cesium.T) cesium.Mono, resourceCleanup func(cesium.T)) cesium.Mono {
	onPublish := func(subscriber cesium.Subscriber, scheduler cesium.Scheduler) cesium.Subscription {
		if scheduler == nil {
			scheduler = SeparateGoroutineScheduler()
		}

		var subscription cesium.Subscription
		subscriptionMux := sync.Mutex{}
		resource := resourceSupplier()

		canc := scheduler.Schedule(func(c cesium.Canceller) {
			subscriptionMux.Lock()
			p := DoFinallyProcessor(func() {
				resourceCleanup(resource)
			})

			subscription = p.Subscribe(subscriber)
			subscriber.OnSubscribe(subscription)
			secondarySubscription := sourceSupplier(resource).Subscribe(p)
			p.OnSubscribe(secondarySubscription)

			subscriptionMux.Unlock()
		})

		for {
			subscriptionMux.Lock()
			if subscription != nil {
				subscriptionMux.Unlock()
				break
			}
			subscriptionMux.Unlock()
		}

		sub := &Subscription{
			CancelFunc: func() {
				subscription.Cancel()
				canc.Cancel()
			},
			RequestFunc: func(n int64) {
				subscription.Request(n)
			},
		}

		subscriber.OnSubscribe(sub)
		return sub
	}

	return &Mono{OnSubscribe: onPublish}
}

// Create allows you to programmatically create a cesium.Mono with the
// capability of emitting multiple elements in a synchronous or asynchronous
// manner through the mono.Sink API
func MonoCreate(f func(cesium.MonoSink)) cesium.Mono {
	onPublish := func(subscriber cesium.Subscriber, scheduler cesium.Scheduler) cesium.Subscription {
		if scheduler == nil {
			scheduler = SeparateGoroutineScheduler()
		}

		sinkMux := sync.Mutex{}
		var sink *MonoSink

		cancellable := scheduler.Schedule(func(c cesium.Canceller) {
			sinkMux.Lock()
			sink = BufferMonoSink(subscriber, c)
			sinkMux.Unlock()
			f(sink)
		})

		for {
			sinkMux.Lock()
			if sink != nil {
				sinkMux.Unlock()
				break
			}
			sinkMux.Unlock()
		}

		sub := &Subscription{
			CancelFunc: func() {
				cancellable.Cancel()
			},
			RequestFunc: func(n int64) {
				sink.Request(n)
			},
		}

		subscriber.OnSubscribe(sub)
		return sub
	}

	return &Mono{OnSubscribe: onPublish}
}
